from collections import OrderedDict
import copy
import os
import platform
import subprocess
import time

from backupnow.bnlogging import emit_cast
from backupnow import sync_dir
from backupnow.moresmb import get_mounted_share, split_share


class BNJob:
    def __init__(self, mounts=None):
        if mounts is None:
            mounts = OrderedDict()
        self.mounts = mounts

    def _run_operation(self, operation, destination,
                       require_subdirectory=True,
                       event_template=None,
                       status_cb=None):
        """Run a single backup operation.
        A job with more than one operation requires multiple calls.

        Args:
            operation (dict): Settings for a single backup operation.
                - "detect_destination_file": ".BackupGoNow-settings.txt",
                - "detect_destination_folder": Example: "3D Models",
                - "detect_source_folder": "Design and Development",
                - "source": "\\\\DATACENTER\\3D Models"
            require_subdirectory (bool): Require a subdirectory
                to be specified to be either required via
                operation['detect_destination_folder'] or created (via
                operation['destination_subfolder']) under destination.
                If False, and neither are specified, destination folder
                will be *deleted* and/or updated with a copy of source!
            event_template (dict): Basis for creating
                the return dict. If None, return dict will only have
                values generated by the method.
            status_cb (Callable): Function to call for progress,
                accepting one arg which is event (dict) containing one
                or more of (at least 'done' and event_template's keys):
                - 'done' (bool)
                - 'files_done' (int)
                - 'files_total' (int)
                - 'ratio' (float)
        Return:
            dict: Information about the operation:
            - 'error' (str): If truthy, indicates the operation failed.
              If 'valid_destination' is False, error can be ignored
              since the reason for not running is clear (It is the
              caller's responsibility for how this method
              is used and what results are allowed).
            - 'valid_destination' (bool): The destination matches the
              requirements of the source.
            - 'valid_source' (bool): The source is known to be correct.
              if False but source is correct, display
              'destination_folders' and 'destination_files' to user
              and allow user to select files to add to
              'detect_destination_file' (allowed to be list) of
              the operation.
        """
        def default_status_cb(d):
            print("[_run_operation default_status_cb] {}".format(d))
        if status_cb is None:
            status_cb = default_status_cb
        detect_dst_file = operation.get('detect_destination_file')
        detect_dst_dir = operation.get('detect_destination_folder')
        source = operation.get('source')
        results = {} if not event_template else copy.deepcopy(event_template)
        results['done'] = False
        results['detect_dst_folders'] = []
        results['detect_dst_files'] = []
        results['detect_source_folders'] = []

        results['found_dst_folders'] = []
        results['found_dst_files'] = []

        results['missing_dst_folders'] = []
        results['missing_dst_files'] = []
        results['missing_source_folders'] = []

        results['valid_source'] = False
        results['valid_destination'] = False
        # destination_sub = detect_dst_dir
        assert destination, "destination is {}".format(repr(destination))
        assert os.path.isdir(destination), \
            "destination {} is not a directory.".format(repr(destination))
        assert source, "The job has no 'source' to backup."
        assert detect_dst_dir, "The job has no 'detect_destination_folder'."
        dst_sub = operation.get("destination_subfolder")
        if detect_dst_dir:
            if not isinstance(detect_dst_dir, list):
                dst_sub = detect_dst_dir
            elif len(detect_dst_dir) == 1:
                dst_sub = detect_dst_dir[0]
            detect_dst_folders = [detect_dst_dir] if not isinstance(
                detect_dst_dir, list) else detect_dst_dir
            for detect_dst_dir in detect_dst_folders:
                results['detect_dst_folders'].append(detect_dst_dir)
                detect_dst_path = os.path.join(destination, detect_dst_dir)
                if os.path.isdir(detect_dst_path):
                    results['found_dst_folders'].append(detect_dst_dir)
                else:
                    results['missing_dst_folders'].append(detect_dst_dir)
        if not dst_sub or not dst_sub.strip():
            dst_sub = None
            if require_subdirectory:
                raise ValueError(
                    "'destination_subfolder' is required if detect_dst_folders"
                    " is a list (as opposed to a single path)")
        if dst_sub:
            dst_path = os.path.join(destination, dst_sub)
        else:
            dst_path = destination

        if detect_dst_file:
            detect_dst_files = [detect_dst_file] if not isinstance(
                detect_dst_file, list) else detect_dst_file
            for detect_dst_file in detect_dst_files:
                results['detect_dst_files'].append(detect_dst_file)
                detect_dst_path = os.path.join(destination, detect_dst_file)
                if os.path.isfile(detect_dst_path):
                    results['found_dst_files'].append(detect_dst_file)
                else:
                    results['missing_dst_files'].append(detect_dst_file)
        if (results['missing_dst_folders'] or results['missing_dst_files']):
            results['error'] = (
                "There is no {} on {}".format(
                    (results['missing_dst_folders']
                     + results['missing_dst_files']),
                    destination
                )
            )
            return results
        results['valid_destination'] = True
        if source.startswith("\\\\"):
            share, src_sub = split_share(source)
            src_mount_path = get_mounted_share(share)
            if not src_mount_path:
                raise OSError("Failed to mount {}".format(share))
            src_path = os.path.join(src_mount_path, src_sub)
            # time.sleep(2)  # Wait for mount to take effect
            results['source_mount_path'] = src_path
        else:
            src_path = source
        detect_source_folder = operation.get('detect_source_folder')
        if detect_source_folder:
            if isinstance(detect_source_folder, str):
                assert detect_source_folder.strip()
            elif isinstance(detect_source_folder, list):
                for s in detect_source_folder:
                    assert isinstance(s, str)
                    assert s.strip()
            else:
                raise TypeError(
                    "Expected list or str for detect_source_folder, got {}"
                    .format(emit_cast(detect_source_folder)))
            results['detect_source_folders'] = [detect_source_folder] \
                if not isinstance(
                    detect_source_folder, list) else detect_source_folder
            for detect_source_folder in results['detect_source_folders']:
                if not os.path.isdir(os.path.join(src_path,
                                                  detect_source_folder)):
                    results['missing_source_folders'].append(
                        detect_source_folder)
            if results['missing_source_folders']:
                results['error'] = (
                    "Source {} is missing {}".format(
                        repr(source), results['missing_source_folders']
                    ))
                return results

        results['valid_source'] = True
        if 'last_bytes_total' in operation:
            results['last_bytes_total'] = operation['last_bytes_total']
        results = sync_dir(
            src_path,
            dst_path,
            event_template=results,
            status_cb=status_cb,
        )  # excludes=None, exclude_res=None)
        if results.get('bytes_total'):
            operation['last_bytes_total'] = results['bytes_total']
        results['done'] = True
        if status_cb is not None:
            status_cb(results)
        if 'source_mount_path' in results:
            if platform.system() == "Windows":
                cmd = ('net use {} /del /y'.format(
                    results['source_mount_path'].rstrip(os.path.sep)))
                print("[mount_share] " + cmd)
                subprocess.call(cmd, shell=True)
            else:
                NotImplementedError("Unmount is not implemented for {}"
                                    .format(platform.system()))
        return results  # return for synchronous use (not just status_cb)
