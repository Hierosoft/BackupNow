#!/usr/bin/env python3
'''
This module is part of the BackupNow project
by Jake "Poikilos" Gustafson (c) 2021.
You should have a copy of the license.txt file, otherwise see
<https://github.com/Poikilos/BackupNow/blob/main/license.txt>.

If using the CLI, run frequently so that scheduled events can be
checked.
'''
from __future__ import print_function

import copy
import logging
import os
import re
import shutil
import sys

from datetime import datetime
from logging import getLogger

if sys.version_info.major >= 3:
    from datetime import timezone


if __name__ == "__main__":
    MODULE_DIR = os.path.dirname(os.path.realpath(__file__))
    REPO_DIR = os.path.dirname(MODULE_DIR)
    sys.path.insert(0, REPO_DIR)

logger = getLogger(__name__)
# logger.setLevel(INFO)  # does nothing since there are no handlers.
#   (See basicConfig call in verbose case in main instead).
del logging

MODULE_DIR = os.path.dirname(os.path.realpath(__file__))
ASSETS_DIR = os.path.join(MODULE_DIR, "assets")

THEME_ROOT = os.path.join(ASSETS_DIR, "forest-ttk-theme")

SEARCH_DIRS = [
    ASSETS_DIR,
    THEME_ROOT,
    os.path.join(THEME_ROOT, "forest-light"),
    os.path.join(THEME_ROOT, "forest-dark"),
]

ALPHABET_UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"


def best_utc_now():
    # type: () -> datetime
    if sys.version_info.major >= 3:
        return datetime.now(timezone.utc)  # type:ignore
    return datetime.utcnow()


def echo0(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)


def find_resource(name):
    if os.path.exists(name):
        return os.path.realpath(name)
    for parent in SEARCH_DIRS:
        sub_path = os.path.join(parent, name)
        if os.path.exists(sub_path):
            return sub_path
        print("There is no {}".format(sub_path))
    return None


def formatted_ex(ex):
    return "{}: {}".format(type(ex).__name__, ex)


def get_size(start_path, event_template=None, status_cb=None):
    # based on <https://stackoverflow.com/a/1392549>
    total_size = 0
    event = {} if (event_template is None) else copy.deepcopy(event_template)
    num = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            num += 1
            fp = os.path.join(dirpath, f)
            # skip if it is symbolic link
            if status_cb:
                event['message'] = ("Calculating size of {} file(s) in {}"
                                    .format(num, repr(start_path)))
                status_cb(event)
            if not os.path.islink(fp):
                total_size += os.path.getsize(fp)

    return total_size


def getRelPath(root, sub_path):
    if not sub_path.startswith(root):
        raise RuntimeError(
            "Root \"{}\" was lost from sub_path \"{}\""
            .format(root, sub_path))
    return sub_path[len(root)+1:]  # +1 to avoid os.sep (slash)


def getRelPaths(path, sort=True, root=None):
    results = []
    if not path:
        raise ValueError("Path was blank.")
    if root is None:
        root = path

    if sort:
        sorted_subs = sorted(os.listdir(path),  key=lambda s: s.casefold())
        # casefold is more aggressive (will find more characters) than lower()
    else:
        sorted_subs = list(os.listdir(path))

    for sub in sorted_subs:
        sub_path = os.path.join(path, sub)
        if not os.path.isdir(sub_path):
            continue
        sub_rel = getRelPath(root, sub_path)
        results.append(sub_rel)
        results += getRelPaths(sub_path, sort=sort, root=root)

    for sub in sorted_subs:
        sub_path = os.path.join(path, sub)
        if not os.path.isfile(sub_path):
            continue
        sub_rel = getRelPath(root, sub_path)
        results.append(sub_rel)

    return results


def sync_dir(src, dst, excludes=None,
             event_template=None,
             status_cb=None, rel=None,
             dry_run=False, depth=0,
             quiet=True):
    """Copy each file in source where there isn't a matching destination.

    Args:
        src (str): source path
        depth (int): Leave this as the default (directory tree depth,
            computed during recursion). Defaults to 0.
        dst (str): destination path
        excludes (Union[str,re.Pattern], optional): paths or regex
            patterns (checked against path relative to src) to exclude.
            Defaults to None.
        event_template (dict): Basis for creating
            the return dict. If None, return dict will only have
            values generated by the method.
        rel (Optional[str]): Leave as None (relative path to source for
            excludes, computed during recursion).
        status_cb (Callable): Function to call for progress,
            accepting one arg which is event (dict) containing one
            or more of (at least 'done' and event_template's keys):
            - 'done' (bool)
            - 'files_done' (int)
            - 'files_total' (int)
            - 'ratio' (float)
    """
    def default_status_cb(d):
        print("[sync_dir default_status_cb] {}".format(d))
    if status_cb is None:
        status_cb = default_status_cb

    event = {} if event_template is None else event_template
    # ^ reference *NOT copy* in this case, for preserving
    #   counts during recursion.

    if excludes is not None:
        if isinstance(excludes, list):
            for exclude in excludes:
                assert isinstance(exclude, (str, re.Pattern))
        else:
            assert isinstance(excludes, (str, re.Pattern))
            excludes = [excludes]
    src_subs = []
    if 'files_done' not in event:
        event['files_done'] = 0
    if 'files_total' not in event:
        event['files_total'] = 0
    if 'bytes_done' not in event:
        event['bytes_done'] = 0
    if 'bytes_total' not in event:
        event['bytes_total'] = 0
    if 'last_bytes_total' not in event:
        assert depth == 0, "last_bytes_total was not calculated at top level."
        event['last_bytes_total'] = get_size(
            src,
            event_template=event,
            status_cb=status_cb,
        )
        # ^ saved at end of last job. See operation['last_bytes_total']
        event['save_operation_values'] = ['last_bytes_total']
        status_cb(event)
        del event['save_operation_values']

    for sub in os.listdir(src):
        src_sub_path = os.path.join(src, sub)
        sub_rel = os.path.join(rel, sub) if rel else sub
        if excludes is not None:
            for exclude in excludes:
                if isinstance(exclude, str):
                    if sub_rel == exclude:
                        continue
                else:
                    if exclude.match(sub):
                        continue
        src_subs.append(sub)
        if os.path.isfile(src_sub_path):
            event['files_total'] += 1
            event['bytes_total'] += os.path.getsize(src_sub_path)

    # print("rsync -a {}/ {}  # excludes={} rel={}"
    #       .format(repr(src), repr(dst), repr(excludes), repr(rel)))
    made_dst = False
    for sub in src_subs:
        src_sub_path = os.path.join(src, sub)
        dst_sub_path = os.path.join(dst, sub)
        sub_rel = os.path.join(rel, sub) if rel else sub
        # if os.path.islink(src_sub_path):
        if os.path.islink(src_sub_path):
            # Copy even if dangling
            if not quiet:
                print("ln -s `readlink {}` {}".format(repr(src_sub_path),
                                                      repr(dst_sub_path)))
            if not dry_run:
                shutil.copy2(src_sub_path, dst_sub_path)
            continue
        if os.path.isdir(src_sub_path):
            sync_dir(
                src_sub_path,
                dst_sub_path,
                excludes=excludes,
                event_template=event,
                status_cb=status_cb,
                rel=sub_rel,
                depth=depth+1,
                dry_run=dry_run,
                quiet=quiet,
            )
            continue
        elif os.path.isfile(src_sub_path):
            same = False
            if os.path.isfile(dst_sub_path):
                if (os.path.getmtime(dst_sub_path)
                        == os.path.getmtime(src_sub_path)):
                    if (os.path.getsize(dst_sub_path)
                            == os.path.getsize(src_sub_path)):
                        same = True
            if not same:
                if not os.path.isdir(dst):
                    if not dry_run:
                        os.makedirs(dst)
                    if not made_dst:
                        if not quiet:
                            print("mkdir -p {}".format(repr(dst)))
                        made_dst = True
                if not dry_run:
                    shutil.copy2(src_sub_path, dst_sub_path)
                if not quiet:
                    print("cp -a {} {}".format(repr(src_sub_path),
                                               repr(dst_sub_path)))
            event['files_done'] += 1
            event['bytes_done'] += os.path.getsize(src_sub_path)
            event['current_file_rel_path'] = src_sub_path
            if status_cb is not None:
                status_cb(event)
    if depth == 0:
        event['last_files_total'] = event['files_total']
        event['save_operation_values'] = ['last_files_total']
        status_cb(event)
        del event['save_operation_values']

    return event
