#!/usr/bin/env python3
'''
This module is part of the BackupNow project
by Jake "Poikilos" Gustafson (c) 2021.
You should have a copy of the license.txt file, otherwise see
<https://github.com/Poikilos/BackupNow/blob/main/license.txt>.

If using the CLI, run frequently so that scheduled events can be
checked.
'''
from __future__ import print_function

import logging
import os
import re
import sys

from datetime import datetime
from logging import getLogger

if sys.version_info.major >= 3:
    from datetime import timezone


if __name__ == "__main__":
    MODULE_DIR = os.path.dirname(os.path.realpath(__file__))
    REPO_DIR = os.path.dirname(MODULE_DIR)
    sys.path.insert(0, REPO_DIR)

logger = getLogger(__name__)
# logger.setLevel(INFO)  # does nothing since there are no handlers.
#   (See basicConfig call in verbose case in main instead).
del logging

MODULE_DIR = os.path.dirname(os.path.realpath(__file__))
ASSETS_DIR = os.path.join(MODULE_DIR, "assets")

THEME_ROOT = os.path.join(ASSETS_DIR, "forest-ttk-theme")

SEARCH_DIRS = [
    ASSETS_DIR,
    THEME_ROOT,
    os.path.join(THEME_ROOT, "forest-light"),
    os.path.join(THEME_ROOT, "forest-dark"),
]

ALPHABET_UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"


def best_utc_now():
    # type: () -> datetime
    if sys.version_info.major >= 3:
        return datetime.now(timezone.utc)  # type:ignore
    return datetime.utcnow()


def echo0(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)


def find_resource(name):
    if os.path.exists(name):
        return os.path.realpath(name)
    for parent in SEARCH_DIRS:
        sub_path = os.path.join(parent, name)
        if os.path.exists(sub_path):
            return sub_path
        print("There is no {}".format(sub_path))
    return None


def formatted_ex(ex):
    return "{}: {}".format(type(ex).__name__, ex)


def getRelPath(root, sub_path):
    if not sub_path.startswith(root):
        raise RuntimeError(
            "Root \"{}\" was lost from sub_path \"{}\""
            .format(root, sub_path))
    return sub_path[len(root)+1:]  # +1 to avoid os.sep (slash)


def getRelPaths(path, sort=True, root=None):
    results = []
    if not path:
        raise ValueError("Path was blank.")
    if root is None:
        root = path

    if sort:
        sorted_subs = sorted(os.listdir(path),  key=lambda s: s.casefold())
        # casefold is more aggressive (will find more characters) than lower()
    else:
        sorted_subs = list(os.listdir(path))

    for sub in sorted_subs:
        sub_path = os.path.join(path, sub)
        if not os.path.isdir(sub_path):
            continue
        sub_rel = getRelPath(root, sub_path)
        results.append(sub_rel)
        results += getRelPaths(sub_path, sort=sort, root=root)

    for sub in sorted_subs:
        sub_path = os.path.join(path, sub)
        if not os.path.isfile(sub_path):
            continue
        sub_rel = getRelPath(root, sub_path)
        results.append(sub_rel)

    return results


def sync_dir(src, dst, excludes=None,
             event_template=None,
             status_cb=None, rel=None):
    """Copy each file in source where there isn't a matching destination.

    Args:
        src (str): source path
        dst (str): destination path
        excludes (Union[str,re.Pattern], optional): paths or regex
            patterns (checked against path relative to src) to exclude.
            Defaults to None.
        event_template (dict): Basis for creating
            the return dict. If None, return dict will only have
            values generated by the method.
        rel (Optional[str]): Leave as None (relative path to source for
            excludes, computed during recursion).
        status_cb (Callable): Function to call for progress,
            accepting one arg which is event (dict) containing one
            or more of (at least 'done' and event_template's keys):
            - 'done' (bool)
            - 'files_done' (int)
            - 'files_total' (int)
            - 'ratio' (float)
    """
    event = {} if event_template is None else event_template
    # ^ reference *NOT* copy in this case, for preserving
    #   counts during recursion.
    if excludes is not None:
        if isinstance(excludes, list):
            for exclude in excludes:
                assert isinstance(exclude, (str, re.Pattern))
        else:
            assert isinstance(excludes, (str, re.Pattern))
            excludes = [excludes]
    src_subs = []
    if 'files_done' not in event:
        event['files_done'] = 0
    if 'files_total' not in event:
        event['files_total'] = 0

    for sub in os.listdir(src):
        src_sub_path = os.path.join(src, sub)
        sub_rel = os.path.join(rel, sub) if rel else sub
        if excludes is not None:
            for exclude in excludes:
                if isinstance(exclude, str):
                    if sub_rel == exclude:
                        continue
                else:
                    if exclude.match(sub):
                        continue
        src_subs.append(sub)
        if os.path.isfile(src_sub_path):
            event['files_total'] += 1
            event['bytes_total'] += os.path.getsize(src_sub_path)

    print("rsync -a {}/ {}  # excludes={} rel={}"
          .format(repr(src), repr(dst), repr(excludes), repr(rel)))
    return # for debug only

    for sub in src_subs:
        src_sub_path = os.path.join(src, sub)
        dst_sub_path = os.path.join(dst, sub)
        sub_rel = os.path.join(rel, sub) if rel else sub
        # if os.path.islink(src_sub_path):
        if os.path.islink(src_sub_path):
            # Copy even if dangling
            shutil.copy2(src_sub_path, dst_sub_path)
            continue
        if os.path.isdir(src_sub_path):
            sync_dir(
                src_sub_path,
                dst_sub_path,
                excludes=excludes,
                event_template=event,
                rel=sub_rel,
            )
            continue
        elif os.path.isfile(src_sub_path):
            same = False
            if os.path.isfile(dst_sub_path):
                if (os.path.getmtime(dst_sub_path)
                        == os.path.getmtime(src_sub_path)):
                    if (os.path.getsize(dst_sub_path)
                            == os.path.getsize(src_sub_path)):
                        same = True
            if not same:
                if not os.path.isdir(dst):
                    os.makedirs(dst)
                shutil.copy2(src_sub_path, dst_sub_path)
        event['files_done'] += 1
        event['bytes_done'] += os.path.getsize(src_sub_path)
        if status_cb is not None:
            status_cb(event)
